; Generated by c86 (BYU-NASM) 5.1 (beta) from DelayQueue.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
initializeDelayQueue:
	; >>>>> Line:	9
	; >>>>> void initializeDelayQueue() { 
	jmp	L_DelayQueue_1
L_DelayQueue_2:
	; >>>>> Line:	10
	; >>>>> delayQueue.size = 0; 
	mov	word [(2+delayQueue)], 0
	; >>>>> Line:	11
	; >>>>> delayQueue.head = 0; 
	mov	word [delayQueue], 0
	mov	sp, bp
	pop	bp
	ret
L_DelayQueue_1:
	push	bp
	mov	bp, sp
	jmp	L_DelayQueue_2
	ALIGN	2
tickClock:
	; >>>>> Line:	14
	; >>>>> (current 
	jmp	L_DelayQueue_4
L_DelayQueue_5:
	; >>>>> Line:	20
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	21
	; >>>>> if (delayQueue.size == 0) { 
	mov	ax, word [(2+delayQueue)]
	test	ax, ax
	jne	L_DelayQueue_6
	; >>>>> Line:	22
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	23
	; >>>>> return; 
	jmp	L_DelayQueue_7
L_DelayQueue_6:
	; >>>>> Line:	26
	; >>>>> current = delayQueue.head; 
	mov	ax, word [delayQueue]
	mov	word [bp-2], ax
	; >>>>> Line:	27
	; >>>>> if (delayQueue.size == 1) { 
	cmp	word [(2+delayQueue)], 1
	jne	L_DelayQueue_8
	; >>>>> Line:	28
	; >>>>> current->delayCount--; 
	mov	si, word [bp-2]
	add	si, 8
	dec	word [si]
	; >>>>> Line:	29
	; >>>>> if (current->delayCount == 0) { 
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_DelayQueue_9
	; >>>>> Line:	30
	; >>>>> delayQueue.head = 0; 
	mov	word [delayQueue], 0
	; >>>>> Line:	31
	; >>>>> delayQueue.size = 0; 
	mov	word [(2+delayQueue)], 0
	; >>>>> Line:	32
	; >>>>> current->next = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	33
	; >>>>> current->prev = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	34
	; >>>>> current->state = T_READY; 
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], 1
	; >>>>> Line:	35
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	36
	; >>>>> insertPriorityQueue(&readyQueue, current); 
	push	word [bp-2]
	mov	ax, readyQueue
	push	ax
	call	insertPriorityQueue
	add	sp, 4
	; >>>>> Line:	38
	; >>>>> return; 
	jmp	L_DelayQueue_7
L_DelayQueue_9:
	; >>>>> Line:	40
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	41
	; >>>>> return; 
	jmp	L_DelayQueue_7
L_DelayQueue_8:
	; >>>>> Line:	44
	; >>>>> current->delayCount--; 
	mov	si, word [bp-2]
	add	si, 8
	dec	word [si]
	; >>>>> Line:	45
	; >>>>> while (current 
	jmp	L_DelayQueue_11
L_DelayQueue_10:
	; >>>>> Line:	46
	; >>>>> current = delayQueue.head; 
	mov	ax, word [delayQueue]
	mov	word [bp-2], ax
	; >>>>> Line:	47
	; >>>>> if (current->delayCount == 0) { 
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_DelayQueue_13
	; >>>>> Line:	48
	; >>>>> delayQueue.head = current->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [delayQueue], ax
	; >>>>> Line:	49
	; >>>>> if (current->next != 0) { 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_DelayQueue_14
	; >>>>> Line:	50
	; >>>>> current->next->prev = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	word [si], 0
L_DelayQueue_14:
	; >>>>> Line:	52
	; >>>>> current->next = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	53
	; >>>>> current->prev = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	54
	; >>>>> current->state = T_READY; 
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], 1
	; >>>>> Line:	55
	; >>>>> temp = current; 
	mov	ax, word [bp-2]
	mov	word [bp-4], ax
	; >>>>> Line:	56
	; >>>>> delayQueue.size--; 
	dec	word [(2+delayQueue)]
	; >>>>> Line:	57
	; >>>>> insertPriorityQueue(&readyQueue, temp); 
	push	word [bp-4]
	mov	ax, readyQueue
	push	ax
	call	insertPriorityQueue
	add	sp, 4
	; >>>>> Line:	58
	; >>>>> current = delayQueue.head; 
	mov	ax, word [delayQueue]
	mov	word [bp-2], ax
	jmp	L_DelayQueue_15
L_DelayQueue_13:
	; >>>>> Line:	60
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	61
	; >>>>> return; 
	jmp	L_DelayQueue_7
L_DelayQueue_15:
L_DelayQueue_11:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_DelayQueue_10
L_DelayQueue_12:
L_DelayQueue_7:
	mov	sp, bp
	pop	bp
	ret
L_DelayQueue_4:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_DelayQueue_5
	ALIGN	2
insertDelayQueue:
	; >>>>> Line:	67
	; >>>>> void insertDelayQueue(TCB* tcb) { 
	jmp	L_DelayQueue_17
L_DelayQueue_18:
	; >>>>> Line:	73
	; >>>>>  
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_DelayQueue_19
	; >>>>> Line:	73
	; >>>>>  
	jmp	L_DelayQueue_20
L_DelayQueue_19:
	; >>>>> Line:	76
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	77
	; >>>>> if (delayQueue.size == 0) { 
	mov	ax, word [(2+delayQueue)]
	test	ax, ax
	jne	L_DelayQueue_21
	; >>>>> Line:	78
	; >>>>> delayQueue.head = tcb; 
	mov	ax, word [bp+4]
	mov	word [delayQueue], ax
	; >>>>> Line:	79
	; >>>>> tcb->next = 0; 
	mov	si, word [bp+4]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	80
	; >>>>> tcb->prev = 0; 
	mov	si, word [bp+4]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	81
	; >>>>> delayQueue.size++; 
	inc	word [(2+delayQueue)]
	; >>>>> Line:	82
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	83
	; >>>>> return; 
	jmp	L_DelayQueue_20
L_DelayQueue_21:
	; >>>>> Line:	87
	; >>>>> current = delayQueue.head; 
	mov	ax, word [delayQueue]
	mov	word [bp-2], ax
	; >>>>> Line:	88
	; >>>>> sumCount = 0; 
	mov	word [bp-4], 0
	; >>>>> Line:	89
	; >>>>> oldSumCount = 0; 
	mov	word [bp-6], 0
	; >>>>> Line:	90
	; >>>>> while (current != 0) { 
	jmp	L_DelayQueue_23
L_DelayQueue_22:
	; >>>>> Line:	91
	; >>>>> sumCount += current->delayCount; 
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [si]
	add	word [bp-4], ax
	; >>>>> Line:	92
	; >>>>> if (tcb->delayCount < sumCount) { 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [bp-4]
	cmp	ax, word [si]
	jbe	L_DelayQueue_25
	; >>>>> Line:	93
	; >>>>> tcb->next = current; 
	mov	si, word [bp+4]
	add	si, 10
	mov	ax, word [bp-2]
	mov	word [si], ax
	; >>>>> Line:	94
	; >>>>> tcb->prev = current->prev; 
	mov	si, word [bp-2]
	add	si, 12
	mov	di, word [bp+4]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	; >>>>> Line:	95
	; >>>>> if (current == delayQueue.head) { 
	mov	ax, word [delayQueue]
	cmp	ax, word [bp-2]
	jne	L_DelayQueue_26
	; >>>>> Line:	96
	; >>>>> tcb->dela 
	mov	ax, word [bp+4]
	mov	word [delayQueue], ax
	jmp	L_DelayQueue_27
L_DelayQueue_26:
	; >>>>> Line:	98
	; >>>>> current->prev->next = tcb; 
	mov	si, word [bp-2]
	add	si, 12
	mov	si, word [si]
	add	si, 10
	mov	ax, word [bp+4]
	mov	word [si], ax
L_DelayQueue_27:
	; >>>>> Line:	100
	; >>>>> current->prev = tcb; 
	mov	si, word [bp-2]
	add	si, 12
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	101
	; >>>>> delayQueue.size++; 
	inc	word [(2+delayQueue)]
	; >>>>> Line:	102
	; >>>>> tcb->delayCount = tcb->delayCount - oldSumCount; 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	sub	ax, word [bp-6]
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	103
	; >>>>> current->delayCount = current->delayCount - tcb->delayCount; 
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [si]
	mov	si, word [bp+4]
	add	si, 8
	sub	ax, word [si]
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	104
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	105
	; >>>>> return; 
	jmp	L_DelayQueue_20
L_DelayQueue_25:
	; >>>>> Line:	107
	; >>>>> if (current->next == 0) { 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	jne	L_DelayQueue_28
	; >>>>> Line:	108
	; >>>>> current->next = tcb; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	109
	; >>>>> tcb->prev = current; 
	mov	si, word [bp+4]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
	; >>>>> Line:	110
	; >>>>> tcb->next = 0; 
	mov	si, word [bp+4]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	111
	; >>>>> delayQueue.size++; 
	inc	word [(2+delayQueue)]
	; >>>>> Line:	112
	; >>>>> tcb->dela 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	sub	ax, word [bp-4]
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	113
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	114
	; >>>>> return; 
	jmp	L_DelayQueue_20
L_DelayQueue_28:
	; >>>>> Line:	116
	; >>>>> current = current->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-2], ax
	; >>>>> Line:	117
	; >>>>> oldSumCount = sumCount; 
	mov	ax, word [bp-4]
	mov	word [bp-6], ax
L_DelayQueue_23:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_DelayQueue_22
L_DelayQueue_24:
L_DelayQueue_20:
	mov	sp, bp
	pop	bp
	ret
L_DelayQueue_17:
	push	bp
	mov	bp, sp
	sub	sp, 6
	jmp	L_DelayQueue_18
L_DelayQueue_30:
	DB	"Printing Delay Queue with size ",0
	ALIGN	2
printDelayQueue:
	; >>>>> Line:	122
	; >>>>> void printDelayQueue(void) { 
	jmp	L_DelayQueue_31
L_DelayQueue_32:
	; >>>>> Line:	127
	; >>>>> current = delayQueue.head; 
	mov	ax, word [delayQueue]
	mov	word [bp-2], ax
	; >>>>> Line:	128
	; >>>>> printString("Printing Delay Queue with size "); 
	mov	ax, L_DelayQueue_30
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	129
	; >>>>> printInt(delayQueue.size); 
	push	word [(2+delayQueue)]
	call	printInt
	add	sp, 2
	; >>>>> Line:	130
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	132
	; >>>>> while (current != 0) { 
	jmp	L_DelayQueue_34
L_DelayQueue_33:
	; >>>>> Line:	133
	; >>>>> printInt(current->priority); 
	mov	si, word [bp-2]
	add	si, 2
	mov	al, byte [si]
	xor	ah, ah
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	134
	; >>>>> printString(" "); 
	mov	ax, (L_DelayQueue_30+30)
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	135
	; >>>>> printInt(current->delayCount); 
	mov	si, word [bp-2]
	add	si, 8
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	136
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	137
	; >>>>> current = current->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-2], ax
L_DelayQueue_34:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_DelayQueue_33
L_DelayQueue_35:
	mov	sp, bp
	pop	bp
	ret
L_DelayQueue_31:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_DelayQueue_32
