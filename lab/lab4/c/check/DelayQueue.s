; Generated by c86 (BYU-NASM) 5.1 (beta) from DelayQueue.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
initializeDelayQueue:
	; >>>>> Line:	8
	; >>>>> void initializeDelayQueue() { 
	jmp	L_DelayQueue_1
L_DelayQueue_2:
	; >>>>> Line:	9
	; >>>>> delayQueue.size = 0; 
	mov	word [(2+delayQueue)], 0
	; >>>>> Line:	10
	; >>>>> delayQueue.head = 0; 
	mov	word [delayQueue], 0
	mov	sp, bp
	pop	bp
	ret
L_DelayQueue_1:
	push	bp
	mov	bp, sp
	jmp	L_DelayQueue_2
	ALIGN	2
tickClock:
	; >>>>> Line:	13
	; >>>>> gned  
	jmp	L_DelayQueue_4
L_DelayQueue_5:
	; >>>>> Line:	19
	; >>>>> if (delayQueue.size == 0) return; 
	mov	ax, word [(2+delayQueue)]
	test	ax, ax
	jne	L_DelayQueue_6
	; >>>>> Line:	19
	; >>>>> if (delayQueue.size == 0) return; 
	jmp	L_DelayQueue_7
L_DelayQueue_6:
	; >>>>> Line:	22
	; >>>>> current = delayQueue.head; 
	mov	ax, word [delayQueue]
	mov	word [bp-2], ax
	; >>>>> Line:	23
	; >>>>> while (current != 0) { 
	jmp	L_DelayQueue_9
L_DelayQueue_8:
	; >>>>> Line:	24
	; >>>>> current->delayCount--; 
	mov	si, word [bp-2]
	add	si, 8
	dec	word [si]
	; >>>>> Line:	25
	; >>>>> temp = current; 
	mov	ax, word [bp-2]
	mov	word [bp-4], ax
	; >>>>> Line:	26
	; >>>>> current = current->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-2], ax
	; >>>>> Line:	27
	; >>>>> if (temp->delayCount == 0) { 
	mov	si, word [bp-4]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_DelayQueue_11
	; >>>>> Line:	29
	; >>>>> if (temp->next != 0) { 
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_DelayQueue_12
	; >>>>> Line:	30
	; >>>>> temp->next->prev = 0; 
	mov	si, word [bp-4]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	word [si], 0
L_DelayQueue_12:
	; >>>>> Line:	32
	; >>>>> delayQueue.head = temp->next; 
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	mov	word [delayQueue], ax
	; >>>>> Line:	33
	; >>>>> temp->next = 0; 
	mov	si, word [bp-4]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	34
	; >>>>> temp->prev = 0; 
	mov	si, word [bp-4]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	35
	; >>>>> delayQueue.size--; 
	dec	word [(2+delayQueue)]
	; >>>>> Line:	36
	; >>>>> insertReadyQueue(temp); 
	push	word [bp-4]
	call	insertReadyQueue
	add	sp, 2
L_DelayQueue_11:
L_DelayQueue_9:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_DelayQueue_8
L_DelayQueue_10:
L_DelayQueue_7:
	mov	sp, bp
	pop	bp
	ret
L_DelayQueue_4:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_DelayQueue_5
	ALIGN	2
insertDelayQueue:
	; >>>>> Line:	42
	; >>>>> void insertDelayQueue(TCB* tcb) { 
	jmp	L_DelayQueue_14
L_DelayQueue_15:
	; >>>>> Line:	47
	; >>>>> if (tcb == 0) return; 
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_DelayQueue_16
	; >>>>> Line:	47
	; >>>>> if (tcb == 0) return; 
	jmp	L_DelayQueue_17
L_DelayQueue_16:
	; >>>>> Line:	50
	; >>>>> if (delayQueue.size == 0) { 
	mov	ax, word [(2+delayQueue)]
	test	ax, ax
	jne	L_DelayQueue_18
	; >>>>> Line:	51
	; >>>>> delayQueue.head = tcb; 
	mov	ax, word [bp+4]
	mov	word [delayQueue], ax
	; >>>>> Line:	52
	; >>>>> tcb->next = 0; 
	mov	si, word [bp+4]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	53
	; >>>>> tcb->prev = 0; 
	mov	si, word [bp+4]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	54
	; >>>>> delayQueue.size++; 
	inc	word [(2+delayQueue)]
	; >>>>> Line:	55
	; >>>>> return; 
	jmp	L_DelayQueue_17
L_DelayQueue_18:
	; >>>>> Line:	59
	; >>>>> current = delayQueue.head; 
	mov	ax, word [delayQueue]
	mov	word [bp-2], ax
	; >>>>> Line:	60
	; >>>>> sumCount = 0; 
	mov	word [bp-4], 0
	; >>>>> Line:	61
	; >>>>> while (current != 0) { 
	jmp	L_DelayQueue_20
L_DelayQueue_19:
	; >>>>> Line:	62
	; >>>>> sumCount += current->delayCount; 
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [si]
	add	word [bp-4], ax
	; >>>>> Line:	63
	; >>>>> if (tcb->delayCount < sumCount) { 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [bp-4]
	cmp	ax, word [si]
	jbe	L_DelayQueue_22
	; >>>>> Line:	64
	; >>>>> tcb->prev = current->prev; 
	mov	si, word [bp-2]
	add	si, 12
	mov	di, word [bp+4]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	; >>>>> Line:	65
	; >>>>> tcb->next = current; 
	mov	si, word [bp+4]
	add	si, 10
	mov	ax, word [bp-2]
	mov	word [si], ax
	; >>>>> Line:	66
	; >>>>> if (current == delayQueue.head) { 
	mov	ax, word [delayQueue]
	cmp	ax, word [bp-2]
	jne	L_DelayQueue_23
	; >>>>> Line:	67
	; >>>>> delayQueue.head  
	mov	ax, word [bp+4]
	mov	word [delayQueue], ax
	; >>>>> Line:	68
	; >>>>> current->prev->next = tcb; 
	mov	si, word [bp-2]
	add	si, 12
	mov	si, word [si]
	add	si, 10
	mov	word [si], ax
L_DelayQueue_23:
	; >>>>> Line:	70
	; >>>>> current->prev = tcb; 
	mov	si, word [bp-2]
	add	si, 12
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	71
	; >>>>> delayQueue.size++; 
	inc	word [(2+delayQueue)]
	; >>>>> Line:	72
	; >>>>> tcb->delayCount = tcb->delayCount - sumCount; 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	sub	ax, word [bp-4]
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	73
	; >>>>> return; 
	jmp	L_DelayQueue_17
L_DelayQueue_22:
	; >>>>> Line:	75
	; >>>>> if (current->next == 0) { 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	jne	L_DelayQueue_24
	; >>>>> Line:	76
	; >>>>> current->next = tcb; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	77
	; >>>>> tcb->prev = current; 
	mov	si, word [bp+4]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
	; >>>>> Line:	78
	; >>>>> tcb->next = 0; 
	mov	si, word [bp+4]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	79
	; >>>>> delayQueue.size++; 
	inc	word [(2+delayQueue)]
	; >>>>> Line:	80
	; >>>>> tcb->delayCount = tcb->delayCount - sumCount; 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	sub	ax, word [bp-4]
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	81
	; >>>>> return; 
	jmp	L_DelayQueue_17
L_DelayQueue_24:
	; >>>>> Line:	83
	; >>>>> current = current->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-2], ax
L_DelayQueue_20:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_DelayQueue_19
L_DelayQueue_21:
L_DelayQueue_17:
	mov	sp, bp
	pop	bp
	ret
L_DelayQueue_14:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_DelayQueue_15
