; Generated by c86 (BYU-NASM) 5.1 (beta) from yakc.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
L_yakc_4:
	DW	0
L_yakc_6:
	DW	0
L_yakc_7:
	DW	0
	ALIGN	2
getYKCtxSwCount:
	; >>>>> Line:	16
	; >>>>> unsigned int getYKCtxSwCount() { 
	jmp	L_yakc_8
L_yakc_9:
	; >>>>> Line:	17
	; >>>>> return YKCtxSwCount; 
	mov	ax, word [L_yakc_6]
L_yakc_10:
	mov	sp, bp
	pop	bp
	ret
L_yakc_8:
	push	bp
	mov	bp, sp
	jmp	L_yakc_9
	ALIGN	2
YKInitialize:
	; >>>>> Line:	20
	; >>>>>  
	jmp	L_yakc_12
L_yakc_13:
	; >>>>> Line:	21
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	24
	; >>>>> initializeReadyQueue(); 
	call	initializeReadyQueue
	; >>>>> Line:	25
	; >>>>> initializeDelayQueue(); 
	call	initializeDelayQueue
	; >>>>> Line:	26
	; >>>>> taskBlock.nextFreeTCB = 0; 
	mov	word [(56+L_yakc_1)], 0
	; >>>>> Line:	28
	; >>>>> YKNewTask(YKIdleTask, &idleStack[3], 100); 
	mov	al, 100
	push	ax
	mov	ax, (L_yakc_2+6)
	push	ax
	mov	ax, YKIdleTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	30
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_12:
	push	bp
	mov	bp, sp
	jmp	L_yakc_13
	ALIGN	2
YKEnterMutex:
	; >>>>> Line:	33
	; >>>>> void YKEnterMutex(void){ 
	jmp	L_yakc_15
L_yakc_16:
	; >>>>> Line:	34
	; >>>>> asm("cli"); 
	cli
	mov	sp, bp
	pop	bp
	ret
L_yakc_15:
	push	bp
	mov	bp, sp
	jmp	L_yakc_16
	ALIGN	2
YKExitMutex:
	; >>>>> Line:	37
	; >>>>> void YKExitMutex(void){ 
	jmp	L_yakc_18
L_yakc_19:
	; >>>>> Line:	38
	; >>>>> asm("sti"); 
	sti
	mov	sp, bp
	pop	bp
	ret
L_yakc_18:
	push	bp
	mov	bp, sp
	jmp	L_yakc_19
	ALIGN	2
YKIdleTask:
	; >>>>> Line:	41
	; >>>>> void YKIdleTask(void){ 
	jmp	L_yakc_21
L_yakc_22:
	; >>>>> Line:	44
	; >>>>> while(1){ 
	jmp	L_yakc_24
L_yakc_23:
	; >>>>> Line:	45
	; >>>>> dummy++; 
	inc	word [bp-2]
	; >>>>> Line:	46
	; >>>>> dummy--; 
	dec	word [bp-2]
	; >>>>> Line:	47
	; >>>>> YKIdleCount++; 
	inc	word [L_yakc_7]
L_yakc_24:
	jmp	L_yakc_23
L_yakc_25:
	mov	sp, bp
	pop	bp
	ret
L_yakc_21:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_22
	ALIGN	2
YKNewTask:
	; >>>>> Line:	51
	; >>>>> void YKNewTask(void (*task)(void), void *taskStack, unsigned char priority){ 
	jmp	L_yakc_27
L_yakc_28:
	; >>>>> Line:	54
	; >>>>> newTCB = getNewTCB(); 
	call	getNewTCB
	mov	word [bp-2], ax
	; >>>>> Line:	55
	; >>>>> if(newTCB == 0) { 
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_29
	; >>>>> Line:	56
	; >>>>> exit(-1); 
	mov	ax, -1
	push	ax
	call	exit
	add	sp, 2
L_yakc_29:
	; >>>>> Line:	60
	; >>>>> TASK_ID+ 
	inc	word [L_yakc_4]
	; >>>>> Line:	61
	; >>>>> newTCB->tid = TASK_ID; 
	mov	si, word [bp-2]
	mov	ax, word [L_yakc_4]
	mov	word [si], ax
	; >>>>> Line:	62
	; >>>>> newTCB->priority = priority; 
	mov	si, word [bp-2]
	add	si, 2
	mov	al, byte [bp+8]
	mov	byte [si], al
	; >>>>> Line:	63
	; >>>>> newTCB->stackPointer = ((void*)((int*) taskStack - 12)); 
	mov	ax, word [bp+6]
	sub	ax, 24
	mov	si, word [bp-2]
	add	si, 4
	mov	word [si], ax
	; >>>>> Line:	64
	; >>>>> newTCB->state = T_READY; 
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], 1
	; >>>>> Line:	65
	; >>>>> newTCB->delayCount = 0; 
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], 0
	; >>>>> Line:	66
	; >>>>> newTCB->next = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	67
	; >>>>> newTCB->prev = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	70
	; >>>>> asm("push bx"); 
	push bx
	; >>>>> Line:	71
	; >>>>> asm("push cx"); 
	push cx
	; >>>>> Line:	72
	; >>>>> asm("mov bx, [bp+6]"); 
	mov bx, [bp+6]
	; >>>>> Line:	73
	; >>>>> asm("mov cx, [bp+4]"); 
	mov cx, [bp+4]
	; >>>>> Line:	74
	; >>>>> asm("mov [bx-2], word 0x0200"); 
	mov [bx-2], word 0x0200
	; >>>>> Line:	75
	; >>>>> asm("mov [bx-4], word 0x0"); 
	mov [bx-4], word 0x0
	; >>>>> Line:	76
	; >>>>> asm("mov [bx-6], cx"); 
	mov [bx-6], cx
	; >>>>> Line:	77
	; >>>>> asm("pop cx"); 
	pop cx
	; >>>>> Line:	78
	; >>>>> asm("pop bx"); 
	pop bx
	; >>>>> Line:	81
	; >>>>> insertReadyQueue(newTCB); 
	push	word [bp-2]
	call	insertReadyQueue
	add	sp, 2
	; >>>>> Line:	82
	; >>>>> YKScheduler(); 
	call	YKScheduler
L_yakc_30:
	; >>>>> Line:	83
	; >>>>> return; 
	mov	sp, bp
	pop	bp
	ret
L_yakc_27:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_28
	ALIGN	2
YKRun:
	; >>>>> Line:	86
	; >>>>> void YKRun(void){ 
	jmp	L_yakc_32
L_yakc_33:
	; >>>>> Line:	87
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	88
	; >>>>> ask = &taskB 
	mov	word [L_yakc_3], 1
	; >>>>> Line:	89
	; >>>>> YKScheduler(); 
	call	YKScheduler
	; >>>>> Line:	90
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_32:
	push	bp
	mov	bp, sp
	jmp	L_yakc_33
	ALIGN	2
YKScheduler:
	; >>>>> Line:	93
	; >>>>> void YKScheduler(void){ 
	jmp	L_yakc_35
L_yakc_36:
	; >>>>> Line:	96
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	97
	; >>>>> if(kernelState == K_BLOCKED) { 
	mov	ax, word [L_yakc_3]
	test	ax, ax
	jne	L_yakc_37
	; >>>>> Line:	98
	; >>>>> return; 
	jmp	L_yakc_38
L_yakc_37:
	; >>>>> Line:	100
	; >>>>> newTask = peekReadyQueue(); 
	call	peekReadyQueue
	mov	word [bp-2], ax
	; >>>>> Line:	101
	; >>>>> if(newTask == 0) { 
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_39
	; >>>>> Line:	102
	; >>>>> exit(-2); 
	mov	ax, -2
	push	ax
	call	exit
	add	sp, 2
L_yakc_39:
	; >>>>> Line:	104
	; >>>>> if(newTask != currentTask) { 
	mov	ax, word [L_yakc_5]
	cmp	ax, word [bp-2]
	je	L_yakc_40
	; >>>>> Line:	105
	; >>>>> currentTask->state = T_READY; 
	mov	si, word [L_yakc_5]
	add	si, 6
	mov	word [si], 1
	; >>>>> Line:	106
	; >>>>> currentTask = newTask; 
	mov	ax, word [bp-2]
	mov	word [L_yakc_5], ax
	; >>>>> Line:	107
	; >>>>> currentTask->state = T_RUNNING; 
	mov	si, word [L_yakc_5]
	add	si, 6
	mov	word [si], 2
	; >>>>> Line:	108
	; >>>>> YKCtxSwCount++; 
	inc	word [L_yakc_6]
	; >>>>> Line:	109
	; >>>>> YKDispatcher(); 
	call	YKDispatcher
L_yakc_40:
	; >>>>> Line:	111
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_38:
	; >>>>> Line:	112
	; >>>>> return; 
	mov	sp, bp
	pop	bp
	ret
L_yakc_35:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_36
	ALIGN	2
getNewTCB:
	; >>>>> Line:	134
	; >>>>> TCB* getNewTCB(void) { 
	jmp	L_yakc_42
L_yakc_43:
	; >>>>> Line:	136
	; >>>>> if (taskBlock.nextFreeTCB < 3 + 1) { 
	cmp	word [(56+L_yakc_1)], 4
	jae	L_yakc_44
	; >>>>> Line:	137
	; >>>>> task = &taskB 
	mov	ax, word [(56+L_yakc_1)]
	mov	cx, 14
	imul	cx
	add	ax, L_yakc_1
	mov	word [bp-2], ax
	; >>>>> Line:	138
	; >>>>> taskBlock.nextFreeTCB++; 
	inc	word [(56+L_yakc_1)]
	; >>>>> Line:	139
	; >>>>> return task; 
	mov	ax, word [bp-2]
	jmp	L_yakc_45
	jmp	L_yakc_46
L_yakc_44:
	; >>>>> Line:	141
	; >>>>> return 0; 
	xor	ax, ax
L_yakc_46:
L_yakc_45:
	mov	sp, bp
	pop	bp
	ret
L_yakc_42:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_43
	ALIGN	2
readyQueue:
	TIMES	6 db 0
delayQueue:
	TIMES	4 db 0
L_yakc_1:
	TIMES	58 db 0
L_yakc_2:
	TIMES	6 db 0
L_yakc_3:
	TIMES	2 db 0
L_yakc_5:
	TIMES	2 db 0
